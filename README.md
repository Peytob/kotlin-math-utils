# Kotlin Math Utils (KMU)

Библиотека математических функций и объектов. Библиотека предназначается для разработки в области компьютерной графики и процедурной генерации.

Реализация линейной алгебры сделана таким образом, что может быть удобно использована совместно с [LWJGL](https://github.com/LWJGL/lwjgl3) (OpenGL). Многие методы и функции портированы из [GLM](https://github.com/g-truc/glm) и полностью соответствуют методам GLM, однако полного соответствия достичь не удалось.

Предыдущая версия библиотеки базировалась на генерации кода векторов и всех операций посредствам Kpoet. Однако, количество усилий при генерации кода значительно увеличивается и усложняется отладка. Так как этой библиотекой пользуется буквально один человек (ее автор) - проще отказаться от кодогенерации :)

### Решаемая проблема

Главная проблема реализации любой математической библиотеки на Java или Kotlin - generic не может нормально обрабатывать математические операции, даже если указать Number как базовый тип. То есть создать функцию plus следующего вида не представляется возможным:

```kotlin
fun <T : Number> plus(a: T, b: T): T {
    return a + b // <- error!
}
```

Из невозможности создания метода такого типа вытекает невозможность адекватного создания арифметических и алгебраических методов для векторов, матриц и иных мат. объектов. Теоретически возможно использование исключительно базового типа Number во всех мат. объектах и построение новых операторов через switch. Но это просто огромный оверхед и костыль

```kotlin
fun Number.plus(other: Number): Number {
    return when (this) {
        is Long -> this.toLong() + other.toLong()
        is Int -> this.toInt() + other.toInt()
        is Short -> this.toShort() + other.toShort()
        is Byte -> this.toByte() + other.toByte()
        is Double -> this.toDouble() + other.toDouble()
        is Float -> this.toFloat() + other.toFloat()
        else -> throw IllegalArgumentException()
    }
}
```

Кроме того возникает проблема при работе с массивами данных, используемыми OGL и подобными ему инструментами. Наиболее простым решением выглядит простое копирование кода под каждый из кейсов, либо использование кодогенерации. Кодогенерацией выходит заметно дольше и проблемнее, чем полуавтоматический подход к написанию через макросы. Поэтому данная библиотека сгенерирована на основе нескольких шаблонов и макросов, слегка отредактированных вручную.

## Features

### Вектора

Поддерживаемые виды векторов:

+ Двухкомпонентные вектора вида (x, y)
+ Трехкомпонентные вектора вида (x, y, z)

Поддерживаемые типы данных векторов:

+ Float (float32)
+ Double (float64)
+ Int (int32)
+ Long (int64)

Поддерживаемые операции над векторами:

+ Базовые арифметические операции вектор - вектор (сложение (+), вычитание (-), векторное (*) и скалярное (dot) произведение)
+ Базовые арифметические операции вектор - скаляр (сложение (+), вычитание (-), векторное (*) произведение)
+ Упаковка вектора в любой из типов Java NIO Buffer

На данный момент поддерживается только организация векторов в памяти только подходом AoS. В будущем планируется поддержка подхода SoA.

### Матрицы

Пока что и тут пусто...

### Шумы

Пока что и тут пусто...

### Геометрические примитивы

Поддерживаемые геометрические примитивы:

+ Прямоугольники

Поддерживаемые типы данных прямоугольников:

+ Float (float32)
+ Int (int32)

Поддерживаемые операции над геометрическими примитивами:

+ Проверка вхождения точки в прямоугольник или пересечения двух прямоугольников; поиск области пересечения прямоугольников

### Правила выполнения вычислений

При выполнении всех арифметических операций происходит автоматическое приведение примитива результирующего вектора к типу **левого** операнда. Это касается типов в любых арифметических операциях. Таким образом появляется возможность создавать меньшее количество объектов и использовать меньшее количество приведений типов при работе.

Рассмотрим приведение примитивов векторов при сложении. Аналогично для любых других операций.

```kotlin
val a: Vec2f = immutableVec2f(1.1f, 4.2f)
val b: Vec2i = immutableVec2i(2, 5)

val apb: Vec2f = a + b // (3.1f, 9.2f)
val bpa: Vec2i = b + a // (3, 9)
```

В случае, если операция определена для двух векторов, может быть реализована flat-версия операции, принимающая раскрытый вектор. Результаты операций должны быть одинаковы и flat-операции используются для более гибкого API, которое может иногда позволить сэкономить на создании объектов векторов:

```kotlin
val a: Vec2f = immutableVec2f(1.5f, 2.0f)
val b: Vec2f = immutableVec2f(5.0, 2.0)

val sumVectorized: Vec2f = a + b // also can be used as function: a.plus(b)
val sumFlat: Vec2f = a.plus(rx = b.x, ry = b.y)

assert(sumVectorized == sumFlat)

val distanceVectorized: Vec2f = distance(a, b)
val distanceFlat: Vec2f = distance(lx = a.x, ly = a.y, rx = b.x, ry = b.y)

assert(distanceVectorized == distanceFlat)
```

### Demo

Пока что и тут пусто...
